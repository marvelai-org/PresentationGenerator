import React, { useEffect, useState } from 'react';
import { TemplateSlot } from '../TemplateRegistry';
import { 
  ConstraintElement, 
  SizeConstraint,
  PositionConstraint 
} from '@/lib/layout';
import TemplateSlotRenderer from './TemplateSlotRenderer';
import { Box, useTheme } from '@mui/material';

interface DynamicTemplateProps {
  slots: TemplateSlot[];
  data: Record<string, any>;
  width?: number;
  height?: number;
  onContentChange?: (id: string, value: any) => void;
  editable?: boolean;
}

/**
 * Dynamic Template component that renders templates generated by the
 * automated layout engine. Handles rendering of all slot types and
 * applies constraints from the layout engine.
 */
const DynamicTemplate: React.FC<DynamicTemplateProps> = ({
  slots,
  data,
  width = 800,
  height = 450,
  onContentChange,
  editable = false
}) => {
  const theme = useTheme();
  const [slotBounds, setSlotBounds] = useState<Record<string, { x: number, y: number, width: number, height: number }>>({});
  
  // Calculate dimensions for each slot based on constraints
  useEffect(() => {
    const calculatedBounds: Record<string, { x: number, y: number, width: number, height: number }> = {};
    
    slots.forEach(slot => {
      const constraints = slot.constraints || {};
      
      // Calculate position (x, y)
      let x = 0;
      let y = 0;
      
      if (constraints.position) {
        if (typeof constraints.position.x === 'number') {
          x = constraints.position.x;
        } else if (constraints.position.x?.percentage) {
          x = (constraints.position.x.percentage / 100) * width;
        }
        
        if (typeof constraints.position.y === 'number') {
          y = constraints.position.y;
        } else if (constraints.position.y?.percentage) {
          y = (constraints.position.y.percentage / 100) * height;
        }
      }
      
      // Calculate size (width, height)
      let slotWidth = 200; // Default width
      let slotHeight = 100; // Default height
      
      if (constraints.size) {
        if (typeof constraints.size.width === 'number') {
          slotWidth = constraints.size.width;
        } else if (constraints.size.width?.percentage) {
          slotWidth = (constraints.size.width.percentage / 100) * width;
        }
        
        if (typeof constraints.size.height === 'number') {
          slotHeight = constraints.size.height;
        } else if (constraints.size.height?.percentage) {
          slotHeight = (constraints.size.height.percentage / 100) * height;
        }
      }
      
      calculatedBounds[slot.id] = {
        x,
        y,
        width: slotWidth,
        height: slotHeight
      };
    });
    
    setSlotBounds(calculatedBounds);
  }, [slots, width, height]);
  
  // Handle content change in a slot
  const handleContentChange = (id: string, value: any) => {
    if (onContentChange) {
      onContentChange(id, value);
    }
  };
  
  return (
    <Box 
      sx={{ 
        position: 'relative',
        width: width,
        height: height,
        backgroundColor: theme.palette.background.paper,
        boxShadow: theme.shadows[2],
        overflow: 'hidden',
        borderRadius: 1
      }}
    >
      {slots.map(slot => {
        const bounds = slotBounds[slot.id];
        
        if (!bounds) return null;
        
        return (
          <Box
            key={slot.id}
            sx={{
              position: 'absolute',
              left: bounds.x,
              top: bounds.y,
              width: bounds.width,
              height: bounds.height,
              padding: theme.spacing(1),
              boxSizing: 'border-box',
              transition: 'all 0.3s ease',
              ...(editable && {
                '&:hover': {
                  outline: `2px dashed ${theme.palette.primary.main}`,
                  outlineOffset: '-2px',
                  cursor: 'pointer'
                }
              })
            }}
          >
            <TemplateSlotRenderer
              slot={slot}
              value={data[slot.id]}
              onChange={(value) => handleContentChange(slot.id, value)}
              editable={editable}
              bounds={{
                width: bounds.width,
                height: bounds.height
              }}
            />
          </Box>
        );
      })}
    </Box>
  );
};

export default DynamicTemplate; 